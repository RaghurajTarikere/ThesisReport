% !TeX spellcheck = en_US

\chapter{Infrastructural code generation}
\label{chap: Code generation}
\section{Introduction}
After designing an OBSW model using the OSRA editor and following the component-based software development approach that comes it, the OBSW model entities need to be mapped to the infrastructure code. The reference programming model discussed in the previous chapter could be used with OSRA helps us in progressing towards this goal. But, it is necessary to understand the overall design approach for the generated code and briefly present the abstractions that will be offered to the software supplier and these topics are dealt with in detail in this chapter.

Similar efforts were are also performed in the Artemis JU CHESS project \cite{EvoRAVCodeAr} and these efforts provides the perfect base for discussions in this chapter of the Master thesis.   

\section{User model entities in the Platform Independent Model (PIM) phase}
A detailed description of all the modeling entities that the software architect can use, can be found in the specification of the metamodel for the OSRA component model \cite{SpecMetamodel}. However a brief description of them is useful here:
 
\begin{description}
\item [Datatypes] The software architect can create a set of project-specific data types and constants using the Datatypes language unit of the CommponTypes metamodel and the language unit is designed to provide the software architect an expressive power comparable to languages with strong types (e.g. Ada).\cite{SpecMetamodel}. The supported type definitions are boolean types, integer types, float types, enumeration types, fixed point types, array types, structured types, string types, union types, alias types, opaque types, external types and unconstrained types. Some of the datatype definitions are obvious for readers with programming skills in types languages such as Ada, C or C++. 

\item [Interfaces] An interface is a specification of coherent set of services and it represents the definition of a contract. An interface is defined independently of the entities implementing it (e.g. Component type). An interface may enlist declaration of operations, which are the functional services that shall be offered by the entities implementing it. The services include a name, set of ordered parameters. Parameters are typed with one of the types mentioned above and have a mode (in, out or inout). A component type may expose one or more interfaces and the same interface can be exposed by different component types. An interface may also contain the declaration of one or more interface attributes, which are the parameters that are accessible via the interface implementation.

\item [Component type] Component type is an entity which specifies the external interface of a software component and are defined in isolation and used to declare relationships with the other components and system in general. It conforms to the principle of encapsulation and a consequence all the interactions with other components are performed exclusively via its explicitly declared interface. Component type usually encompasses:
\begin{itemize}
\item List of provided interface ports
\item List of required interface ports
\item List of dataset emitter ports 
\item List of dataset receiver ports
\item List of event emitter ports
\item List of event receiver ports 
\end{itemize}

\item [Component implementation] It is the entity that represents a concrete realization of a component type. It is functionally identical to the component type and the source code is added to the component implementation and may also define number of component implementation attributes

\item [Component instance] It is an instantiation of a component implementation and hence contains all the instantiations of the structural features (Different ports). It also contains instantiation of all attributes (interface attributes, component type attributes and component implementation attributes). It is also the elementary deployment unit for the OSRA component model.        
\end{description}

\section{Mapping of design entities to the infrastructural code}
As the generated code should target the Tasking framework, which is the target computational model in this Master thesis and because the Tasking framework is written in C++, the following sections explains mapping of design entities to the infrastructure code that will be generated in C++. Certain terms specific to C++ only are used in this section.

On analyzing the specification of the metamodel for the OSRA component model \cite{SpecMetamodel}, it is clear that there might be different corner cases that might possibly arise in the construction of the OBSW models using OSRA component model and it is necessary that these corner cases are effectively handled in the software design for the infrastructural code. An effort is made to first of all build an OBSW model which incorporates these corner cases and in the following sections, an attempt is made to answer the questions at hand.

\subsection{An example OBSW model}
Our simple OBSW model, yet effective to serve the intended purpose, is built as per the proposed component-based development approach explained in the section \cref{Design steps} in chapter \cref{Software development process}. As already mentioned in that section the component-based approach puts a lot of emphasis on the definition of component interfaces \cite{CompBasedProcess} and it is followed here as well. Components are built from scratch using newly defined interfaces

\begin{description}
\item [Step 1: Definition of data types and events] As the Master thesis requires to emphasize more on capturing interaction and concurrency semantics required for communication between the designed components effectively, the data types chosen in this example are fairly simple. But it is important to note that the scheme of mapping of these simple datatypes to the infrastructural code, can be scaled to fairly complex datatypes as well.

Two datatypes namely \texttt{FixedLengthStringType} and \texttt{IntegerType} with \texttt{integerKind} set to \texttt{UNSIGNED} are defined (instantiated from the OSRA Component Model \cite{SpecMetamodel}) and they are named as \texttt{StringType} and \texttt{IntegerType} respectively. Three exception types, named as \texttt{OperandException}, \texttt{MemoryException} and \texttt{OverflowException} are defined. An \texttt{Event} type, which can be used for asynchronous notification \cite{SpecMetamodel} is instantiated and it is named as \texttt{FailureEvent}. Two parameters namely \texttt{m\_Param} and \texttt{m\_Description} with datatypes \texttt{IntegerType} and \texttt{StringType} are instantiated as parameters of the event \texttt{FailureEvent}

\item [Step 2: Definition of interfaces] Two interface namely \texttt{InterfaceA} and \texttt{InterfaceB} are designed. \texttt{InterfaceA} has only one single operation by name \texttt{callOperationAdd} and \texttt{InterfaceB} has an operation by name \texttt{OperationAdd} and an interface attribute of datatype \texttt{IntegerType} named as \texttt{m\_StatusValue}.

The \texttt{OperationAdd} has three parameters, out of which two parameters have \texttt{ParameterDirectionKind} set to \texttt{in} and the third parameter has the \texttt{ParameterDirectionKind} set to \texttt{out}. The \texttt{OperationAdd} is also configured to return any of the three exception kinds mentioned in the previous step. The interface attribute \texttt{m\_StatusValue} has the \texttt{AttributeKind} set to \texttt{CFG} which indicates that the interface attribute parameter is a configurable parameter \texttt{SpecMetamodel}  

\item [Step 3: Component types] Component types namely \texttt{Component\_Caller} and \texttt{Component\_Callee} which form the basis for a reusable software asset are defined. 

\texttt{Component\_Caller} has one provided interface port named as \texttt{ProvidedInterfacePort} and two required interface ports named as \texttt{RequiredInterfacePortType1} and \texttt{RequiredInterfacePortType2}. \texttt{ProvidedInterfacePort} refers to \texttt{InterfaceA} and both \texttt{RequiredInterfacePortType1} and \texttt{RequiredInterfacePortType2} refer to \texttt{InterfaceB}. All the operations in the \texttt{RequiredInterfacePortType1} have the desired interaction kind set to \texttt{synchronous} and all the operations in the \texttt{RequiredInterfacePortType2} have the desired interaction kind set to \texttt{asynchronous} (Note that, it is possible to independently choose the desired interaction kind for each operation \cite{SpecMetamodel}).

\texttt{Component\_Callee} has two provided interface ports named as \texttt{ProvidedInterfacePort1} and \texttt{ProvidedInterfacePort2} and no required interface port. Both \texttt{ProvidedInterfacePort1} and \texttt{ProvidedInterfacePort2} refer to \texttt{InterfaceB}.

\item [Step 4: Component implementation]

\end{description}
   
\subsection{Interface}
An interface can be mapped as a pure virtual base class in C++. For each operation in the interface, a function is added to this virtual base class. The possible parameters of the operation are also added   

\section{Mapping of design entities to the infrastructural code}    
In this section, it is explained how the design entities could be mapped to the infrastructure code that needs to be generated with the model-code transformations through the help of a simple example:

\subsection{Problem description}
A very simple OBSW model consists of two components, namely \texttt{ComponentA} and \texttt{ComponentB} 

\texttt{ComponentA} has the following requirements:
\begin{itemize}
\item The function \texttt{startOperation} implemented in the component implementation needs to be called on the periodic basis with a period of two seconds.

\item There should be two required interface ports. 
\begin{itemize}
\item First required interface port allows \texttt{ComponentA} to call an operation named \texttt{operationAdd}, set and get the status value \texttt{statusValue} with concurrency kind \texttt{immediate}
\item Second required interface port allows \texttt{ComponentA} to call the same operation \texttt{operationAdd}, allows to set and get the same status value \texttt{statusValue} with concurrency kind as \texttt{deffered}. 
\end{itemize}

\item Can receive messages or events asynchronously and there should be a event receiver port which listens to a particular event called the \texttt{FailureEvent} 

\item Can receive a report \texttt{OperationAddReport} for the operation \texttt{operationAdd} which is called. The report has status of the operation \texttt{operationAdd} called the \texttt{operationAddStatus} and the exception for the operation \texttt{operationAdd} called the \texttt{OperationAddException} 
\end{itemize}

\texttt{ComponentB} has the following requirements:
\begin{itemize}
\item Provides two component implementations. Both the implementations provides their own
\begin{itemize}
\item Versions of the operation \texttt{operationAdd} which can be called by any other components
\item Instances of the status value \texttt{statusValue} which can be written to and read from other components 
\end{itemize}

\item Two provided interface ports and they have non-functional requirements attached to them 
\begin{itemize}
\item First provided interface port works with the first version of component implementation and it requires \texttt{operationAdd} to be a \texttt{protected} operation and needs the status value \texttt{statusValue} to be set and get in an unprotected way
\item Second provided interface port works with the second version of component implementation and it requires \texttt{operationAdd} to be called in a sporadic way with a \texttt{Minimum Inter-Arrival Time (MIAT)} of two seconds and needs the status value \texttt{statusValue} to be set and get in an protected way.
\end{itemize}

\item Can send messages or events asynchronously and there should be a event emitter port which emits a particular event called the \texttt{FailureEvent}

\item Can send report report \texttt{OperationAddReport} for the operation \texttt{operationAdd} which is called. The report has status of the operation \texttt{operationAdd} called the \texttt{operationAddStatus} and the exception for the operation \texttt{operationAdd} called the \texttt{OperationAddException} 
\end{itemize}  

From the above description it is clear that these components can be connected to each other or in particular the first required interface port can be connected to the first provided interface port and the second required interface port can be connected to the second provided interface port. The following different design entities are thereby constructed:

\subsection{Design entities}
\subsubsection{Interfaces}
Interfaces are implemented as C++ pure virtual classes and they have entries for the interface operations, interface attribute access operations and interface attributes. Concrete implementations for the interface operations and the interface attribute access operations need to be provided by the classes that implement these interfaces

For the above example:
 
Two primary interfaces can be created based on the problem description namely: 
\begin{description}
\item [\texttt{InterfaceA}] This specifies a single operation \texttt{startOperation}
\item [\texttt{InterfaceB}] This specifies 
\begin{itemize}
\item The operation \texttt{operationAdd}
\item Actual status value \texttt{statusValue}
\item Getter operation for the status value \texttt{statusValue} called \texttt{getStatusValue}
\item Setter operation for the status value \texttt{statusValue} called \texttt{setStatusValue}
\end{itemize}
\end{description}

Three secondary interfaces for \texttt{InterfaceB} are created: 
\begin{description}
\item [\texttt{InterfaceB\textunderscore Synchronous}] which redefines the interface \texttt{InterfaceB} for cases where the operations in the interface \texttt{InterfaceB} are called synchronously
\item [\texttt{InterfaceB\textunderscore Asynchronous}] which redefines the interface \texttt{InterfaceB} for cases where the operations in the interface \texttt{InterfaceB} are called asynchronously
\item [\texttt{InterfaceB\textunderscore extension}] which inherits the interface \texttt{InterfaceB} to add additional operations to handle the situation when the operations in the interface \texttt{InterfaceB} are called asynchronously
\end{description}

\subsubsection{Operation parameter structures}
As the operations can be called with concurrency kind defined as \texttt{deferred}, it is necessary to pack in C++ structures the parameters of the operation (if any) and the address of the component to which the result of the operation (if any), status report of the operation (if any) needs to be sent. This encapsulates all the data necessary to compute the operation, to store the result of the operation and the location to which the result of the operation needs to be sent.  

For the above example:

Two operation parameter structures are required namely:
\begin{description}
\item [\texttt{operationAddStruct}] which holds the parameters of the operation \texttt{operationAdd} and also the address of the component to which the result of the operation \texttt{operationAdd} needs to be sent back
\item [\texttt{statusValueStruct}] which holds the status value and also the address of the component to which the result of the operation \texttt{getStatusValue} needs to be sent
\end{description}

\subsubsection{Operation exceptions}
As the operations executed can lead to different kind of exceptions, they must be delivered back to the component which called the operation. They can be defined as enums in C++.

For the above example:

As the operation \texttt{operationAdd} can raise an exception \texttt{OperationAddException}, it is defined as an enum with enum parameters \texttt{OperandException, MemoryException, OverflowException, none}

\subsubsection{Operation status}
The execution status of the operations may be necessary to be delivered to the caller and the statuses are defined as an enums in C++.

For the above example:

The status of the operation \texttt{operationAdd} can be sent to the component which makes the call. It is defined as an enum \texttt{OperationAddStatus} with enum parameters \texttt{Started, Running, Finished}  

\subsubsection{Operation reports}
For a particular operation, the enums of exceptions and status descriptions can be instantiated in a report. These reports are realized as C++ structs.

For the above example:

One operation report is required namely:
\begin{description}
\item [\texttt{OperationAddReport}] holds the instantiation of the enum \texttt{OperationAddException} and of the enum \texttt{OperationAddStatus} 
\end{description}     

\subsubsection{Call back operations and event receptions}
Pure virtual C++ classes are needed for specifying:
\begin{itemize}
\item The call back operations for 
\begin{itemize}
\item Results of the operations (if any)
\item The statuses of the operations (if any)
\end{itemize}
\item The call back operations for interface attribute getter operations
\item Event reception operations
\end{itemize}

For the above example:

Three pure virtual classes are required namely:
\begin{description}
\item [\texttt{AsynchronousRequirementsOperationAdd}] specifies the call back operation for operation \texttt{operationAdd} which consist of the result of the operation available in operation parameter structure \texttt{OperationAddStruct} and the report for the operation \texttt{OperationAddReport}
\item [\texttt{AsynchronousRequirementsStatusValue}] specifies the call back operation for getter operation of the status \texttt{statusValue}
\item [\texttt{AsynchronousRequirementsFailureEventReception}] specifies the event reception operation 
\end{description}

\subsubsection{Component types}
Component types are implemented as pure virtual classes in C++. A component type specifies the means for instances of it to connect with other components. They realize the interfaces and also realize the pure virtual classes which specify the call back operations and the event receptions.

For the above example:

There are two component types namely:
\begin{description}
\item [\texttt{ComponentType\textunderscore Caller}] implements three pure virtual classes namely:
\begin{itemize}
\item \texttt{InterfaceA}
\item \texttt{AsynchronousRequirementsOperationAdd} as it calls operation \texttt{operationAdd} with concurrency kind \texttt{deferred}
\item \texttt{AsynchronousRequirementsStatusValue} as it calls operation \texttt{getStatusValue} with concurrency kind \texttt{deferred}
\item \texttt{AsynchronousRequirementsFailureEventReception} as it receives event \texttt{FailureEvent}
\end{itemize}
\item [\texttt{ComponentType\textunderscore Callee}] implements \texttt{InterfaceB} only
\end{description}

\subsubsection{Component implementations}
Component implementations contain the definition of the component type and contains concrete implementations for all the operations in the interfaces it inherits from, for all the call back operations and the event reception operations which were specified in their respective classes. Component implementations are implemented as instantiable C++ classes.

For the above example:

There are two component implementations namely:
\begin{description}
\item [\texttt{ComponentImplementation\textunderscore Caller}] inherits from the \texttt{ComponentType\textunderscore Caller} and provides concrete implementations for all the classes that it indirectly inherits from
\item [\texttt{ComponentImplementation\textunderscore Callee}] A    

   



 


 
