% !TeX spellcheck = en_US

\chapter{Infrastructural code generation}
\label{chap: Code generation}
\section{Introduction}
After designing an OBSW model using the OSRA editor and following the component-based software development approach that comes with it, the OBSW model entities need to be mapped to the infrastructure code. The reference programming model for OSRA, discussed in the previous chapter helps us in progressing towards this goal. But, it is necessary to understand the overall design approach for the generated code and briefly present the abstractions that will be offered to the software supplier. This chapter, deals with this in detail.

Similar efforts from the Artemis JU CHESS project \cite{EvoRAVCodeAr}, provides the perfect base for discussions in this chapter of the Master thesis.   

\section{User model entities in the Platform Independent Model (PIM) phase}
A detailed description of all the modeling entities that the software architect can use, can be found in the specification of the metamodel for the OSRA component model \cite{SpecMetamodel}. However a brief description of them is useful here:
 
\begin{description}
\item [Datatypes] The software architect can create a set of project-specific data types and constants using the Datatypes language unit of the CommponTypes metamodel and the language unit is designed to provide the software architect an expressive power comparable to languages with strong types (e.g. Ada).\cite{SpecMetamodel}. The supported type definitions are boolean types, integer types, float types, enumeration types, fixed point types, array types, structured types, string types, union types, alias types, opaque types, external types and unconstrained types. Some of the data type definitions are obvious for readers with programming skills in types languages such as Ada, C or C++. 

\item [Interfaces] An interface is a specification of coherent set of services and it represents the definition of a contract. An interface is defined independently of the entities implementing it (e.g. Component type). An interface may enlist declaration of operations, which are the functional services that shall be offered by the entities implementing it. The services include a name, set of ordered parameters. Parameters are typed with one of the types mentioned above and have a mode (\texttt{in, out or inout}). A component type may expose one or more interfaces and the same interface can be exposed by different component types. An interface may also contain the declaration of one or more interface attributes, which are the parameters that are accessible via the interface implementation.

\item [Component type] Component type is an entity which specifies the external interface of a software component and are defined in isolation and used to declare relationships with the other components and system in general. It conforms to the principle of encapsulation and as a consequence, all the interactions with other components are performed exclusively via its explicitly declared interface. Component type usually encompasses:
\begin{itemize}
\item List of provided interface ports
\item List of required interface ports
\item List of dataset emitter ports 
\item List of dataset receiver ports
\item List of event emitter ports
\item List of event receiver ports 
\end{itemize}

\item [Component implementation] It is the entity that represents a concrete realization of a component type. It is functionally identical to the component type and the source code is added to the component implementation and may also define number of component implementation attributes

\item [Component instance] It is an instantiation of a component implementation and hence contains all the instantiations of the structural features (Different ports). It also contains instantiation of all attributes (interface attributes, component type attributes and component implementation attributes). It is also the elementary deployment unit for the OBSW model \cite{SpecMetamodel}.        
\end{description}

\section{Mapping of design entities to the infrastructural code}
As the generated code should target the Tasking framework, which is the target computational model in this Master thesis and because the Tasking framework is written in C++, the following sections explains mapping of design entities to the infrastructure code that will be generated in C++. Certain terms specific to C++ only, are used in this section.

On analyzing the specification of the metamodel for the OSRA component model \cite{SpecMetamodel}, it is clear that there might be different corner cases that might possibly arise in the construction of the OBSW models using OSRA component model and it is necessary that these corner cases are effectively handled in the software design for the infrastructural code. An effort is made to first of all build an OBSW model which incorporates these corner cases and in the following sections, an attempt is made to answer the questions at hand.

\subsection{An example OBSW model}
Our simple OBSW model, yet effective to serve the intended purpose, is built as per the proposed component-based development approach explained in the section \cref{section: Design steps} in chapter \cref{chap: Software development process}. As already mentioned in that section, the component-based approach puts a lot of emphasis on the definition of component interfaces \cite{CompBasedProcess} and it is followed here as well. Components are built from scratch using newly defined interfaces. All model entities defined here are instantiations of the modeling entities specified in the metamodel \cite{SpecMetamodel}. The OBSW model is designed using the OSRA OBSW model editor mentioned in the section \cref{section: OSRA editor} in chapter \cref{chap: Software development process}.

\begin{description}
\item [Step 1: Definition of data types and events] As the Master thesis requires to emphasize more on effectively capturing interactions and concurrency semantics required for communication between the designed components, the data types chosen in this example are fairly simple. But it is important to note that the scheme of mapping of these simple data types to the infrastructural code (explained in the later sections), can be scaled to fairly complex data types as well.

Two datatypes namely \texttt{Fixed\allowbreak Length\allowbreak String\allowbreak Type} and \texttt{IntegerType} with \texttt{integerKind} set to \texttt{UNSIGNED} are defined and they are named as \texttt{StringType} and \texttt{IntegerType} respectively. Three exception types, named as \texttt{OperandException}, \texttt{MemoryException} and \texttt{Overflow\allowbreak Exception} are defined. An \texttt{Event} type, which can be used for asynchronous notification \cite{SpecMetamodel} is instantiated and it is named as \texttt{FailureEvent}. Two parameters namely \texttt{m\_Param} and \texttt{m\_Description} with data types \texttt{IntegerType} and \texttt{StringType} respectively are instantiated as parameters of the event \texttt{FailureEvent}

\item [Step 2: Definition of interfaces] Two interface namely \texttt{InterfaceA} and \texttt{InterfaceB} are designed. \texttt{InterfaceA} has only one single operation by name \texttt{CallOperationAdd} and \texttt{InterfaceB} has an operation by name \texttt{OperationAdd} and an interface attribute of data type \texttt{IntegerType} and named as \texttt{m\_StatusValue}.

The \texttt{OperationAdd} has three parameters, out of which two parameters have \texttt{Parameter\allowbreak Direction\allowbreak Kind} set to \texttt{in} and the third parameter has the \texttt{Parameter\allowbreak Direction\allowbreak Kind} set to \texttt{out}. The \texttt{OperationAdd} is also configured to return any of the three exception kinds mentioned in the previous step. The interface attribute \texttt{m\_StatusValue} has the \texttt{AttributeKind} set to \texttt{CFG} which indicates that the interface attribute parameter is a configurable parameter \texttt{SpecMetamodel}. As a result, two operations for the purpose of setting and getting the values of the interface attribute are implicitly defined.   

\item [Step 3: Definition of component types] Component types namely \texttt{Component\allowbreak\_Caller} and \texttt{Component\allowbreak\_Callee} which form the basis for a reusable software asset are defined. 

\texttt{Component\allowbreak\_Caller} has one provided interface port named as \texttt{ProvidedInterface\allowbreak Port} and two required interface ports named as \texttt{RequiredInterface\allowbreak PortType1} and \texttt{RequiredInterfaceP\allowbreak PortType2}. \texttt{ProvidedInterface\allowbreak Port} refers to \texttt{InterfaceA} and both \texttt{RequiredInterface\allowbreak PortType1} and \texttt{RequiredInterface\allowbreak PortType2} refer to \texttt{InterfaceB}. All the operations in the \texttt{RequiredInterface\allowbreak PortType1} have the desired interaction kind set to \texttt{synchronous} and all the operations in the \texttt{RequiredInterface\allowbreak PortType2} have the desired interaction kind set to \texttt{asynchronous} (Note that, it is possible to independently choose the desired interaction kind for each operation \cite{SpecMetamodel}). \texttt{Component\allowbreak\_Calller} also has one event receiver port \texttt{FailureEvent\allowbreak ReceiverPort} which refers to the event \texttt{FailureEvent}.

\texttt{Component\_Callee} has two provided interface ports named as \texttt{ProvidedInterface\allowbreak Port1} and \texttt{ProvidedInterface\allowbreak Port2} and no required interface port. Both \texttt{ProvidedInterface\allowbreak Port1} and \texttt{ProvidedInterface\allowbreak Port2} refer to \texttt{InterfaceB}. \texttt{Component\allowbreak\_Callee} also has an event emitter port called the \texttt{FailureEvent\allowbreak EmitterPort} which refers to the event \texttt{FailureEvent}.

\item [Step 4: Definition of component implementation] Component implementations are created from the component types.

\texttt{Component\allowbreak\_Caller} has one component implementation named as \texttt{Component\allowbreak\_Caller\_impl} and \texttt{Component\allowbreak\_Callee} has one component implementation named as \texttt{Component\allowbreak\_Callee\_impl}. The component implementation \texttt{Component\allowbreak\_Callee\_impl} implements the means to store the attribute \texttt{m\_Param} of \texttt{InterfaceB} which is exposed through its provided interface ports namely \texttt{ProvidedInterface\allowbreak Port1} and \texttt{ProvidedInterface\allowbreak Port2}.

No maximum memory footprint for component implementations are defined or no detail design activity of the component implementations are performed as they are not of concern in this Master thesis.

\item [Step 5: Definition of component instances] The component instances are the instances of component implementations \cite{CompBasedProcess}.

Two component instances namely \texttt{Component\allowbreak\_Caller\_impl\_inst} and \texttt{Component\allowbreak\_Callee\_impl\_inst} are instantiated from the component implementations \texttt{Component\allowbreak\_Caller\_impl} and \texttt{Component\allowbreak\_Callee\_impl} respectively. 

\item [Step 6: Definition of component bindings] The following component bindings are defined:

\begin{itemize}
\item The required interface slot \texttt{RequiredInterface\allowbreak SlotType1} of the component instance \texttt{Component\allowbreak\_caller\_impl\_inst} is connected to the provided interface slot \texttt{ProvidedInterface\allowbreak Slot1} of the component instance \texttt{Component\allowbreak\_callee\_impl\_inst}
\item The required interface slot \texttt{RequiredInterface\allowbreak SlotType2} of the component instance \texttt{Component\allowbreak\_caller\_impl\_inst} is connected to the provided interface slot \texttt{ProvidedInterface\allowbreak Slot2} of the component instance \texttt{Component\allowbreak\_callee\_impl\_inst}
\item The event emitter slot \texttt{FailureEvent\allowbreak EmitterSlot} of the component instance \texttt{Component\allowbreak\_callee\_impl\_inst} is connected to the required interface slot \texttt{FailureEvent\allowbreak ReceiverSlot} of the component instance \texttt{Component\allowbreak\_caller\_impl\_inst}
\end{itemize}

\item [Step 7: Specification of non-functional attributes] The non-functional properties are defined on the component instances and the component bindings. The non-functional properties language unit of the specification of a metamodel provides a Value Specification Language (VSL) unit and it permits the specification of the the non-functional properties qualified with a measurement unit \cite{SpecMetamodel}. VSL is used here to define values of non-functional properties with a measurement unit. 

The operations in the provided interface slots, which are the instances of the provided interface ports, that are promoted by the component containers of the respective components are assigned different non-functional properties namely: 
\begin{itemize}
\item The operation \texttt{CallOperationAdd} provided by the \texttt{ProvidedInterface\allowbreak Slot} which refers the \texttt{InterfaceA}, in component instance \texttt{Component\allowbreak\_caller\_impl\_inst} is marked as a cyclic operation with period as 2s
\item The operations in the provided interface port \texttt{ProvidedInterface\allowbreak Slot1} which refers to the interface \texttt{InterfaceB}, in component instance \texttt{Component\allowbreak\_callee\_impl\_inst}, are marked with the following non-functional properties:
\begin{itemize}
\item The operation \texttt{OperationAdd} is marked as a protected operation
\item The interface attribute setter operation for the interface attribute \texttt{m\_StatusValue} is marked as a protected operation
\item The interface attribute getter operation for the interface attribute \texttt{m\_StatusValue} is marked as an unprotected operation
\end{itemize}
\item The operations in the provided interface port \texttt{ProvidedInterface\allowbreak Slot2} which refers to the interface \texttt{InterfaceB}, in component instance \texttt{Component\allowbreak\_callee\_impl\_inst}, are marked with the following non-functional properties: 
\begin{itemize}
\item The operation \texttt{OperationAdd} is marked as a sporadic operation with MIAT as 2s
\item The interface attribute setter operation for the interface attribute \texttt{m\_StatusValue} is marked as a protected operation
\item The interface attribute getter operation for the interface attribute \texttt{m\_StatusValue} is marked as a protected operation
\end{itemize}
\end{itemize}

The event receiver slot \texttt{FailureEvent\allowbreak ReceiverSlot}, which is an instantiation of the event receiver port \texttt{FailureEvent\allowbreak ReceiverPort}, in the component instance \texttt{Component\allowbreak\_caller\_impl\_inst}, is set with the reception of the event \texttt{FailureEvent} as a protected operation.

It is important to note that the WCET and deadline values for the operation in the provided interface slots are not set, as the safeguarding of these properties are not of concern in this Master thesis. 

\item [Step 8: Definition of the physical architecture] The hardware topology provides a description of the system hardware. As hardware modeling is not of concern of this Master thesis, a simple hardware topology is considered. 

A processor board with a processor and a processor core is designed. Two connection docks are attached to the processor board and a bus is attached between between the connection docks. The component instances are deployed on the processor core and the component bindings are deployed on the bus. 
\end{description}

This OBSW model is subjected to model validation against the OSRA Specification Compliance and the SCM meta-model compliance, in the OSRA SCM editor \cite{OSRAEditor}. Only after the OBSW model is successfully validated, can the OBSW model be considered as a suitable candidate for automatic generation of infrastructure code.  

\subsection{Corner cases addressed in the above example model}
   
\subsection{Interface}
An interface can be mapped as a pure virtual base class in C++. For each operation in the interface, a function is added to this virtual base class. The possible parameters of the operation are also added   

\section{Mapping of design entities to the infrastructural code}    
In this section, it is explained how the design entities could be mapped to the infrastructure code that needs to be generated with the model-code transformations through the help of a simple example:

\subsection{Problem description}
A very simple OBSW model consists of two components, namely \texttt{ComponentA} and \texttt{ComponentB} 

\texttt{ComponentA} has the following requirements:
\begin{itemize}
\item The function \texttt{startOperation} implemented in the component implementation needs to be called on the periodic basis with a period of two seconds.

\item There should be two required interface ports. 
\begin{itemize}
\item First required interface port allows \texttt{ComponentA} to call an operation named \texttt{operationAdd}, set and get the status value \texttt{statusValue} with concurrency kind \texttt{immediate}
\item Second required interface port allows \texttt{ComponentA} to call the same operation \texttt{operationAdd}, allows to set and get the same status value \texttt{statusValue} with concurrency kind as \texttt{deffered}. 
\end{itemize}

\item Can receive messages or events asynchronously and there should be a event receiver port which listens to a particular event called the \texttt{FailureEvent} 

\item Can receive a report \texttt{OperationAddReport} for the operation \texttt{operationAdd} which is called. The report has status of the operation \texttt{operationAdd} called the \texttt{operationAddStatus} and the exception for the operation \texttt{operationAdd} called the \texttt{OperationAddException} 
\end{itemize}

\texttt{ComponentB} has the following requirements:
\begin{itemize}
\item Provides two component implementations. Both the implementations provides their own
\begin{itemize}
\item Versions of the operation \texttt{operationAdd} which can be called by any other components
\item Instances of the status value \texttt{statusValue} which can be written to and read from other components 
\end{itemize}

\item Two provided interface ports and they have non-functional requirements attached to them 
\begin{itemize}
\item First provided interface port works with the first version of component implementation and it requires \texttt{operationAdd} to be a \texttt{protected} operation and needs the status value \texttt{statusValue} to be set and get in an unprotected way
\item Second provided interface port works with the second version of component implementation and it requires \texttt{operationAdd} to be called in a sporadic way with a \texttt{Minimum Inter-Arrival Time (MIAT)} of two seconds and needs the status value \texttt{statusValue} to be set and get in an protected way.
\end{itemize}

\item Can send messages or events asynchronously and there should be a event emitter port which emits a particular event called the \texttt{FailureEvent}

\item Can send report report \texttt{OperationAddReport} for the operation \texttt{operationAdd} which is called. The report has status of the operation \texttt{operationAdd} called the \texttt{operationAddStatus} and the exception for the operation \texttt{operationAdd} called the \texttt{OperationAddException} 
\end{itemize}  

From the above description it is clear that these components can be connected to each other or in particular the first required interface port can be connected to the first provided interface port and the second required interface port can be connected to the second provided interface port. The following different design entities are thereby constructed:

\subsection{Design entities}
\subsubsection{Interfaces}
Interfaces are implemented as C++ pure virtual classes and they have entries for the interface operations, interface attribute access operations and interface attributes. Concrete implementations for the interface operations and the interface attribute access operations need to be provided by the classes that implement these interfaces

For the above example:
 
Two primary interfaces can be created based on the problem description namely: 
\begin{description}
\item [\texttt{InterfaceA}] This specifies a single operation \texttt{startOperation}
\item [\texttt{InterfaceB}] This specifies 
\begin{itemize}
\item The operation \texttt{operationAdd}
\item Actual status value \texttt{statusValue}
\item Getter operation for the status value \texttt{statusValue} called \texttt{getStatusValue}
\item Setter operation for the status value \texttt{statusValue} called \texttt{setStatusValue}
\end{itemize}
\end{description}

Three secondary interfaces for \texttt{InterfaceB} are created: 
\begin{description}
\item [\texttt{InterfaceB\textunderscore Synchronous}] which redefines the interface \texttt{InterfaceB} for cases where the operations in the interface \texttt{InterfaceB} are called synchronously
\item [\texttt{InterfaceB\textunderscore Asynchronous}] which redefines the interface \texttt{InterfaceB} for cases where the operations in the interface \texttt{InterfaceB} are called asynchronously
\item [\texttt{InterfaceB\textunderscore extension}] which inherits the interface \texttt{InterfaceB} to add additional operations to handle the situation when the operations in the interface \texttt{InterfaceB} are called asynchronously
\end{description}

\subsubsection{Operation parameter structures}
As the operations can be called with concurrency kind defined as \texttt{deferred}, it is necessary to pack in C++ structures the parameters of the operation (if any) and the address of the component to which the result of the operation (if any), status report of the operation (if any) needs to be sent. This encapsulates all the data necessary to compute the operation, to store the result of the operation and the location to which the result of the operation needs to be sent.  

For the above example:

Two operation parameter structures are required namely:
\begin{description}
\item [\texttt{operationAddStruct}] which holds the parameters of the operation \texttt{operationAdd} and also the address of the component to which the result of the operation \texttt{operationAdd} needs to be sent back
\item [\texttt{statusValueStruct}] which holds the status value and also the address of the component to which the result of the operation \texttt{getStatusValue} needs to be sent
\end{description}

\subsubsection{Operation exceptions}
As the operations executed can lead to different kind of exceptions, they must be delivered back to the component which called the operation. They can be defined as enums in C++.

For the above example:

As the operation \texttt{operationAdd} can raise an exception \texttt{OperationAddException}, it is defined as an enum with enum parameters \texttt{OperandException, MemoryException, OverflowException, none}

\subsubsection{Operation status}
The execution status of the operations may be necessary to be delivered to the caller and the statuses are defined as an enums in C++.

For the above example:

The status of the operation \texttt{operationAdd} can be sent to the component which makes the call. It is defined as an enum \texttt{OperationAddStatus} with enum parameters \texttt{Started, Running, Finished}  

\subsubsection{Operation reports}
For a particular operation, the enums of exceptions and status descriptions can be instantiated in a report. These reports are realized as C++ structs.

For the above example:

One operation report is required namely:
\begin{description}
\item [\texttt{OperationAddReport}] holds the instantiation of the enum \texttt{OperationAddException} and of the enum \texttt{OperationAddStatus} 
\end{description}     

\subsubsection{Call back operations and event receptions}
Pure virtual C++ classes are needed for specifying:
\begin{itemize}
\item The call back operations for 
\begin{itemize}
\item Results of the operations (if any)
\item The statuses of the operations (if any)
\end{itemize}
\item The call back operations for interface attribute getter operations
\item Event reception operations
\end{itemize}

For the above example:

Three pure virtual classes are required namely:
\begin{description}
\item [\texttt{AsynchronousRequirementsOperationAdd}] specifies the call back operation for operation \texttt{operationAdd} which consist of the result of the operation available in operation parameter structure \texttt{OperationAddStruct} and the report for the operation \texttt{OperationAddReport}
\item [\texttt{AsynchronousRequirementsStatusValue}] specifies the call back operation for getter operation of the status \texttt{statusValue}
\item [\texttt{AsynchronousRequirementsFailureEventReception}] specifies the event reception operation 
\end{description}

\subsubsection{Component types}
Component types are implemented as pure virtual classes in C++. A component type specifies the means for instances of it to connect with other components. They realize the interfaces and also realize the pure virtual classes which specify the call back operations and the event receptions.

For the above example:

There are two component types namely:
\begin{description}
\item [\texttt{ComponentType\textunderscore Caller}] implements three pure virtual classes namely:
\begin{itemize}
\item \texttt{InterfaceA}
\item \texttt{AsynchronousRequirementsOperationAdd} as it calls operation \texttt{operationAdd} with concurrency kind \texttt{deferred}
\item \texttt{AsynchronousRequirementsStatusValue} as it calls operation \texttt{getStatusValue} with concurrency kind \texttt{deferred}
\item \texttt{AsynchronousRequirementsFailureEventReception} as it receives event \texttt{FailureEvent}
\end{itemize}
\item [\texttt{ComponentType\textunderscore Callee}] implements \texttt{InterfaceB} only
\end{description}

\subsubsection{Component implementations}
Component implementations contain the definition of the component type and contains concrete implementations for all the operations in the interfaces it inherits from, for all the call back operations and the event reception operations which were specified in their respective classes. Component implementations are implemented as instantiable C++ classes.

For the above example:

There are two component implementations namely:
\begin{description}
\item [\texttt{ComponentImplementation\textunderscore Caller}] inherits from the \texttt{ComponentType\textunderscore Caller} and provides concrete implementations for all the classes that it indirectly inherits from
\item [\texttt{ComponentImplementation\textunderscore Callee}] A    

   



 


 
